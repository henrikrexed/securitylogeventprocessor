
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>securityevent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dynatrace/securitylogeventprocessor/processor/securityevent/config.go (0.0%)</option>
				
				<option value="file1">github.com/dynatrace/securitylogeventprocessor/processor/securityevent/factory.go (0.0%)</option>
				
				<option value="file2">github.com/dynatrace/securitylogeventprocessor/processor/securityevent/internal/openreports/config.go (100.0%)</option>
				
				<option value="file3">github.com/dynatrace/securitylogeventprocessor/processor/securityevent/internal/openreports/processor.go (83.2%)</option>
				
				<option value="file4">github.com/dynatrace/securitylogeventprocessor/processor/securityevent/processor.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package securityevent

import (
        "github.com/dynatrace/securitylogeventprocessor/processor/securityevent/internal/openreports"
)

// Config defines the configuration for the security event processor
type Config struct {
        // Processors defines the list of enabled processors
        Processors ProcessorConfig `mapstructure:"processors"`
}

// ProcessorConfig contains configuration for individual processor types
type ProcessorConfig struct {
        // OpenReports configuration
        OpenReports openreports.Config `mapstructure:"openreports"`
}

// Validate checks if the configuration is valid
func (cfg *Config) Validate() error <span class="cov0" title="0">{
        if err := cfg.Processors.OpenReports.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package securityevent

import (
        "context"

        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/consumer"
        "go.opentelemetry.io/collector/processor"
        "go.opentelemetry.io/collector/processor/processorhelper"
)

var (
        typeStr   = component.MustNewType("securityevent")
        stability = component.StabilityLevelDevelopment
)

// NewFactory creates a new processor factory
func NewFactory() processor.Factory <span class="cov0" title="0">{
        return processor.NewFactory(
                typeStr,
                createDefaultConfig,
                processor.WithLogs(createLogsProcessor, stability),
        )
}</span>

func createDefaultConfig() component.Config <span class="cov0" title="0">{
        return &amp;Config{
                Processors: ProcessorConfig{},
        }
}</span>

func createLogsProcessor(
        ctx context.Context,
        set processor.Settings,
        cfg component.Config,
        nextConsumer consumer.Logs,
) (processor.Logs, error) <span class="cov0" title="0">{
        oCfg := cfg.(*Config)

        processorInstance, err := newSecurityEventProcessor(set.Logger, oCfg, set.TelemetrySettings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return processorhelper.NewLogs(
                ctx,
                set,
                cfg,
                nextConsumer,
                processorInstance.processLogs,
                processorhelper.WithCapabilities(consumer.Capabilities{MutatesData: true}),
        )</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package openreports

import "fmt"

// Config defines the configuration for the OpenReports processor
type Config struct {
        // Enabled indicates whether the OpenReports processor is enabled
        Enabled bool `mapstructure:"enabled"`

        // StatusFilter is an array of result statuses to process
        // Only results with statuses in this list will be transformed into security events
        // Valid values: "pass", "fail", "error", "skip"
        // If empty or not specified, all statuses will be processed
        StatusFilter []string `mapstructure:"status_filter"`
}

// Validate checks if the configuration is valid
func (cfg *Config) Validate() error <span class="cov8" title="1">{
        // Validate status filter values
        validStatuses := map[string]bool{
                "pass":  true,
                "fail":  true,
                "error": true,
                "skip":  true,
        }

        for _, status := range cfg.StatusFilter </span><span class="cov8" title="1">{
                if !validStatuses[status] </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid status in status_filter: %s. Valid values are: pass, fail, error, skip", status)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package openreports

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        "go.opentelemetry.io/collector/pdata/pcommon"
        "go.opentelemetry.io/collector/pdata/plog"
        "go.uber.org/zap"
)

// Processor handles transformation of OpenReports logs into security events
type Processor struct {
        logger *zap.Logger
        config *Config
}

// NewProcessor creates a new OpenReports processor
func NewProcessor(logger *zap.Logger, config *Config) (*Processor, error) <span class="cov8" title="1">{
        return &amp;Processor{
                logger: logger,
                config: config,
        }, nil
}</span>

// ProcessLogRecord processes a single log record and transforms it into multiple security events
// Returns a slice of new log records (one per result) or nil if this is not an OpenReports log
func (p *Processor) ProcessLogRecord(ctx context.Context, logRecord *plog.LogRecord, resource pcommon.Resource, scopeLogs plog.ScopeLogs) ([]plog.LogRecord, error) <span class="cov8" title="1">{
        // Check if this is an OpenReports log by looking for the kind field
        attrs := logRecord.Attributes()
        kindVal, exists := attrs.Get("kind")
        if !exists || kindVal.AsString() != "Report" </span><span class="cov8" title="1">{
                // Not an OpenReports log, skip
                p.logger.Debug("Log record does not match OpenReports processor - kind field check",
                        zap.Bool("kind_exists", exists),
                        zap.String("kind_value", func() string </span><span class="cov8" title="1">{
                                if exists </span><span class="cov8" title="1">{
                                        return kindVal.AsString()
                                }</span>
                                <span class="cov0" title="0">return "missing"</span>
                        }()),
                        zap.String("trace_id", logRecord.TraceID().String()))
                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">apiVersionVal, exists := attrs.Get("apiVersion")
        if !exists || apiVersionVal.AsString() != "openreports.io/v1alpha1" </span><span class="cov0" title="0">{
                // Not an OpenReports log, skip
                p.logger.Debug("Log record does not match OpenReports processor - apiVersion check",
                        zap.Bool("apiVersion_exists", exists),
                        zap.String("apiVersion_value", func() string </span><span class="cov0" title="0">{
                                if exists </span><span class="cov0" title="0">{
                                        return apiVersionVal.AsString()
                                }</span>
                                <span class="cov0" title="0">return "missing"</span>
                        }()),
                        zap.String("trace_id", logRecord.TraceID().String()))
                <span class="cov0" title="0">return nil, nil</span>
        }

        // Log that we've identified an OpenReports log
        <span class="cov8" title="1">p.logger.Debug("OpenReports log identified - processing",
                zap.String("trace_id", logRecord.TraceID().String()),
                zap.String("span_id", logRecord.SpanID().String()),
                zap.String("timestamp", logRecord.Timestamp().String()))

        // Extract metadata for logging
        metadataName, metadataNameExists := attrs.Get("metadata.name")
        scopeName, scopeNameExists := attrs.Get("scope.name")
        scopeKind, scopeKindExists := attrs.Get("scope.kind")

        metadataNameStr := ""
        if metadataNameExists </span><span class="cov8" title="1">{
                metadataNameStr = metadataName.AsString()
        }</span>
        <span class="cov8" title="1">scopeNameStr := ""
        if scopeNameExists </span><span class="cov8" title="1">{
                scopeNameStr = scopeName.AsString()
        }</span>
        <span class="cov8" title="1">scopeKindStr := ""
        if scopeKindExists </span><span class="cov8" title="1">{
                scopeKindStr = scopeKind.AsString()
        }</span>

        <span class="cov8" title="1">p.logger.Debug("OpenReports log metadata",
                zap.String("metadata.name", metadataNameStr),
                zap.String("scope.name", scopeNameStr),
                zap.String("scope.kind", scopeKindStr))

        // Extract the results array
        resultsVal, exists := attrs.Get("results")
        if !exists </span><span class="cov8" title="1">{
                p.logger.Warn("OpenReports log has no results field",
                        zap.String("metadata.name", metadataNameStr))
                return nil, nil
        }</span>

        <span class="cov8" title="1">p.logger.Debug("Parsing OpenReports results array",
                zap.String("results_type", resultsVal.Type().String()),
                zap.Bool("results_exists", exists))

        // Parse results - it's stored as an array/slice of JSON strings
        var resultsArray []string
        if resultsVal.Type() == pcommon.ValueTypeSlice </span><span class="cov8" title="1">{
                // If it's a slice, extract each element as a string
                slice := resultsVal.Slice()
                p.logger.Debug("Results is a slice type",
                        zap.Int("slice_length", slice.Len()))
                for i := 0; i &lt; slice.Len(); i++ </span><span class="cov8" title="1">{
                        resultsArray = append(resultsArray, slice.At(i).AsString())
                }</span>
        } else<span class="cov0" title="0"> if resultsVal.Type() == pcommon.ValueTypeStr </span><span class="cov0" title="0">{
                // If it's a single JSON string containing an array, parse it
                resultStr := resultsVal.AsString()
                p.logger.Debug("Results is a string type, attempting JSON parse",
                        zap.Int("string_length", len(resultStr)))
                var jsonArray []string
                if err := json.Unmarshal([]byte(resultStr), &amp;jsonArray); err == nil </span><span class="cov0" title="0">{
                        resultsArray = jsonArray
                        p.logger.Debug("Successfully parsed JSON array from string",
                                zap.Int("array_length", len(resultsArray)))
                }</span> else<span class="cov0" title="0"> {
                        // Try as single string
                        p.logger.Debug("JSON parse failed, treating as single string result",
                                zap.Error(err))
                        resultsArray = []string{resultStr}
                }</span>
        } else<span class="cov0" title="0"> {
                p.logger.Warn("OpenReports log results field has unexpected type",
                        zap.String("type", resultsVal.Type().String()),
                        zap.String("metadata.name", metadataNameStr))
                return nil, nil
        }</span>

        <span class="cov8" title="1">p.logger.Debug("Parsed results array",
                zap.Int("total_results", len(resultsArray)))

        if len(resultsArray) == 0 </span><span class="cov8" title="1">{
                p.logger.Debug("OpenReports log has empty results array",
                        zap.String("metadata.name", metadataNameStr))
                return nil, nil
        }</span>

        // Extract remaining metadata from the original log
        <span class="cov8" title="1">metadataNamespaceVal, metadataNamespaceExists := attrs.Get("metadata.namespace")
        scopeNamespaceVal, scopeNamespaceExists := attrs.Get("scope.namespace")
        scopeUIDVal, scopeUIDExists := attrs.Get("scope.uid")
        scopeAPIVersionVal, scopeAPIVersionExists := attrs.Get("scope.apiVersion")
        timestamp := logRecord.Timestamp()

        metadataNamespaceStr := ""
        if metadataNamespaceExists </span><span class="cov8" title="1">{
                metadataNamespaceStr = metadataNamespaceVal.AsString()
        }</span>
        <span class="cov8" title="1">scopeNamespaceStr := ""
        if scopeNamespaceExists </span><span class="cov8" title="1">{
                scopeNamespaceStr = scopeNamespaceVal.AsString()
        }</span>
        <span class="cov8" title="1">scopeUIDStr := ""
        if scopeUIDExists </span><span class="cov8" title="1">{
                scopeUIDStr = scopeUIDVal.AsString()
        }</span>
        <span class="cov8" title="1">scopeAPIVersionStr := ""
        if scopeAPIVersionExists </span><span class="cov8" title="1">{
                scopeAPIVersionStr = scopeAPIVersionVal.AsString()
        }</span>

        // Extract workload information from owner references
        <span class="cov8" title="1">p.logger.Debug("Extracting workload information",
                zap.String("scope.name", scopeNameStr),
                zap.String("scope.namespace", scopeNamespaceStr))
        workloadInfo := extractWorkloadInfo(attrs, scopeNameStr, scopeNamespaceStr)

        if workloadInfo.name != "" </span><span class="cov0" title="0">{
                p.logger.Debug("Workload information extracted",
                        zap.String("workload.name", workloadInfo.name),
                        zap.String("workload.kind", workloadInfo.kind),
                        zap.String("workload.namespace", workloadInfo.namespace),
                        zap.String("workload.uid", workloadInfo.uid))
        }</span> else<span class="cov8" title="1"> {
                p.logger.Debug("No workload information found - will infer from pod name if applicable")
        }</span>

        // Log status filter configuration
        <span class="cov8" title="1">if len(p.config.StatusFilter) &gt; 0 </span><span class="cov8" title="1">{
                p.logger.Debug("Status filter active",
                        zap.Strings("allowed_statuses", p.config.StatusFilter),
                        zap.Int("total_results", len(resultsArray)))
        }</span> else<span class="cov8" title="1"> {
                p.logger.Debug("No status filter configured - processing all results",
                        zap.Int("total_results", len(resultsArray)))
        }</span>

        // Create a new log record for each result
        <span class="cov8" title="1">var newRecords []plog.LogRecord
        processedCount := 0
        filteredCount := 0

        for i := 0; i &lt; len(resultsArray); i++ </span><span class="cov8" title="1">{
                resultJSONStr := resultsArray[i]

                p.logger.Debug("Parsing result",
                        zap.Int("result_index", i),
                        zap.Int("result_length", len(resultJSONStr)))

                // Parse the result JSON
                var result Result
                if err := json.Unmarshal([]byte(resultJSONStr), &amp;result); err != nil </span><span class="cov8" title="1">{
                        p.logger.Warn("Failed to parse result JSON",
                                zap.Int("result_index", i),
                                zap.String("result_preview", func() string </span><span class="cov8" title="1">{
                                        if len(resultJSONStr) &gt; 200 </span><span class="cov0" title="0">{
                                                return resultJSONStr[:200] + "..."
                                        }</span>
                                        <span class="cov8" title="1">return resultJSONStr</span>
                                }()),
                                zap.Error(err))
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">p.logger.Debug("Parsed result successfully",
                        zap.Int("result_index", i),
                        zap.String("policy", result.Policy),
                        zap.String("rule", result.Rule),
                        zap.String("result", result.Result),
                        zap.String("source", result.Source))

                // Filter by status if configured
                if len(p.config.StatusFilter) &gt; 0 </span><span class="cov8" title="1">{
                        if !p.isStatusAllowed(result.Result) </span><span class="cov8" title="1">{
                                p.logger.Debug("Skipping result due to status filter",
                                        zap.Int("result_index", i),
                                        zap.String("status", result.Result),
                                        zap.String("policy", result.Policy),
                                        zap.String("rule", result.Rule),
                                        zap.Strings("allowed_statuses", p.config.StatusFilter))
                                filteredCount++
                                continue</span>
                        }
                }

                <span class="cov8" title="1">p.logger.Debug("Result passed status filter, creating security event",
                        zap.Int("result_index", i),
                        zap.String("status", result.Result),
                        zap.String("policy", result.Policy),
                        zap.String("rule", result.Rule))

                // Create a new log record for this result
                newRecord := plog.NewLogRecord()

                // Copy basic fields from original
                newRecord.SetTimestamp(timestamp)
                newRecord.SetObservedTimestamp(logRecord.ObservedTimestamp())
                newRecord.SetSeverityNumber(logRecord.SeverityNumber())
                newRecord.SetSeverityText(logRecord.SeverityText())
                newRecord.SetTraceID(logRecord.TraceID())
                newRecord.SetSpanID(logRecord.SpanID())
                newRecord.SetFlags(logRecord.Flags())

                // Transform the result into a security event
                p.transformToSecurityEvent(&amp;newRecord, result, map[string]interface{}{
                        "metadata.name":      metadataNameStr,
                        "metadata.namespace": metadataNamespaceStr,
                        "scope.name":         scopeNameStr,
                        "scope.namespace":    scopeNamespaceStr,
                        "scope.kind":         scopeKindStr,
                        "scope.uid":          scopeUIDStr,
                        "scope.apiVersion":   scopeAPIVersionStr,
                        "workload.name":      workloadInfo.name,
                        "workload.kind":      workloadInfo.kind,
                        "workload.namespace": workloadInfo.namespace,
                        "workload.uid":       workloadInfo.uid,
                }, attrs)

                newRecords = append(newRecords, newRecord)
                processedCount++</span>
        }

        <span class="cov8" title="1">p.logger.Info("OpenReports log processing completed",
                zap.Int("original_logs", 1),
                zap.Int("total_results", len(resultsArray)),
                zap.Int("processed_results", processedCount),
                zap.Int("filtered_results", filteredCount),
                zap.Int("security_events_created", len(newRecords)),
                zap.String("metadata.name", metadataNameStr),
                zap.String("scope.name", scopeNameStr))

        p.logger.Debug("OpenReports log transformation summary",
                zap.Int("original_logs", 1),
                zap.Int("total_results", len(resultsArray)),
                zap.Int("processed_results", processedCount),
                zap.Int("filtered_results", filteredCount),
                zap.Int("security_events_created", len(newRecords)),
                zap.Bool("status_filter_enabled", len(p.config.StatusFilter) &gt; 0),
                zap.String("metadata.name", metadataNameStr))

        return newRecords, nil</span>
}

// Result represents a single result from the OpenReports results array
type Result struct {
        Source     string                 `json:"source"`
        Timestamp  Timestamp              `json:"timestamp"`
        Message    string                 `json:"message"`
        Policy     string                 `json:"policy"`
        Properties map[string]interface{} `json:"properties"`
        Result     string                 `json:"result"` // pass, fail, error, skip
        Rule       string                 `json:"rule"`
        Scored     bool                   `json:"scored"`
        Severity   string                 `json:"severity,omitempty"`
        Category   string                 `json:"category,omitempty"`
}

// Timestamp represents the timestamp in the result
type Timestamp struct {
        Seconds int64 `json:"seconds"`
        Nanos   int64 `json:"nanos"`
}

// transformToSecurityEvent transforms a result into a security event log record
func (p *Processor) transformToSecurityEvent(logRecord *plog.LogRecord, result Result, metadata map[string]interface{}, originalAttrs pcommon.Map) <span class="cov8" title="1">{
        attrs := logRecord.Attributes()

        // Generate event ID
        eventID := uuid.New().String()
        attrs.PutStr("event.id", eventID)

        // Hardcoded event fields
        attrs.PutStr("event.version", "1.309")
        attrs.PutStr("event.category", "COMPLIANCE")
        attrs.PutStr("event.name", "Compliance finding event")
        attrs.PutStr("event.type", "COMPLIANCE_FINDING")

        // Event description: "Policy violation on &lt;pod&gt; for rule &lt;rule&gt;" or appropriate message based on result
        scopeName := getString(metadata, "scope.name")
        rule := result.Rule
        if rule == "" </span><span class="cov8" title="1">{
                rule = "unknown"
        }</span>

        <span class="cov8" title="1">var eventDescription string
        switch result.Result </span>{
        case "fail":<span class="cov8" title="1">
                eventDescription = fmt.Sprintf("Policy violation on %s for rule %s", scopeName, rule)</span>
        case "pass":<span class="cov8" title="1">
                eventDescription = fmt.Sprintf("Policy check passed on %s for rule %s", scopeName, rule)</span>
        case "error":<span class="cov8" title="1">
                eventDescription = fmt.Sprintf("Policy check error on %s for rule %s", scopeName, rule)</span>
        case "skip":<span class="cov0" title="0">
                eventDescription = fmt.Sprintf("Policy check skipped on %s for rule %s", scopeName, rule)</span>
        default:<span class="cov8" title="1">
                eventDescription = fmt.Sprintf("Policy evaluation on %s for rule %s", scopeName, rule)</span>
        }
        <span class="cov8" title="1">attrs.PutStr("event.description", eventDescription)

        // Product fields (empty for now)
        attrs.PutStr("product.name", "")
        attrs.PutStr("product.vendor", "")

        // Smartscape type - K8S_POD if scope.kind is Pod
        scopeKind := getString(metadata, "scope.kind")
        if scopeKind == "Pod" </span><span class="cov8" title="1">{
                attrs.PutStr("smartscape.type", "K8S_POD")
        }</span>

        // Map finding.severity to dt.security.risk.level
        <span class="cov8" title="1">riskLevel := mapSeverityToRiskLevel(result.Severity)
        attrs.PutStr("dt.security.risk.level", riskLevel)

        // Calculate risk score based on level
        riskScore := calculateRiskScore(riskLevel)
        attrs.PutDouble("dt.security.risk.score", riskScore)

        // Object fields
        scopeUID := getString(metadata, "scope.uid")
        if scopeUID != "" </span><span class="cov8" title="1">{
                attrs.PutStr("object.id", scopeUID)
        }</span>
        <span class="cov8" title="1">if scopeKind != "" </span><span class="cov8" title="1">{
                attrs.PutStr("object.type", scopeKind)
        }</span>

        // Finding fields
        <span class="cov8" title="1">attrs.PutStr("finding.description", result.Message)
        findingID := uuid.New().String()
        attrs.PutStr("finding.id", findingID)

        if result.Severity != "" </span><span class="cov8" title="1">{
                attrs.PutStr("finding.severity", result.Severity)
        }</span>

        // Finding time.created from result timestamp
        <span class="cov8" title="1">if result.Timestamp.Seconds &gt; 0 </span><span class="cov8" title="1">{
                resultTime := time.Unix(result.Timestamp.Seconds, result.Timestamp.Nanos)
                logRecord.SetTimestamp(pcommon.NewTimestampFromTime(resultTime))
                // Also store as finding.time.created
                attrs.PutStr("finding.time.created", resultTime.Format(time.RFC3339Nano))
        }</span>

        // Finding title: policy + rule
        <span class="cov8" title="1">findingTitle := result.Policy
        if result.Rule != "" </span><span class="cov8" title="1">{
                findingTitle = fmt.Sprintf("%s - %s", result.Policy, result.Rule)
        }</span>
        <span class="cov8" title="1">attrs.PutStr("finding.title", findingTitle)

        // Finding type is the policy
        if result.Policy != "" </span><span class="cov8" title="1">{
                attrs.PutStr("finding.type", result.Policy)
        }</span>

        // Finding URL (empty for now)
        <span class="cov8" title="1">attrs.PutStr("finding.url", "")

        // Compliance fields
        if result.Rule != "" </span><span class="cov8" title="1">{
                attrs.PutStr("compliance.control", result.Rule)
        }</span>
        <span class="cov8" title="1">if result.Policy != "" </span><span class="cov8" title="1">{
                attrs.PutStr("compliance.requirements", result.Policy)
        }</span>
        // compliance.standards can be omitted or hardcoded
        // For now, we'll omit it or use category if available
        <span class="cov8" title="1">if result.Category != "" </span><span class="cov8" title="1">{
                attrs.PutStr("compliance.standards", result.Category)
        }</span>

        // Map result.result to compliance.status
        <span class="cov8" title="1">complianceStatus := mapResultToComplianceStatus(result.Result)
        attrs.PutStr("compliance.status", complianceStatus)

        // Copy all k8s.* fields from original log
        copyK8sFields(attrs, originalAttrs, metadata)

        // Set the log body/content to the security event message
        logRecord.Body().SetStr(result.Message)</span>
}

// mapSeverityToRiskLevel maps finding severity to dt.security.risk.level
func mapSeverityToRiskLevel(severity string) string <span class="cov8" title="1">{
        switch severity </span>{
        case "critical":<span class="cov8" title="1">
                return "CRITICAL"</span>
        case "high":<span class="cov8" title="1">
                return "HIGH"</span>
        case "medium":<span class="cov8" title="1">
                return "MEDIUM"</span>
        case "low":<span class="cov8" title="1">
                return "LOW"</span>
        default:<span class="cov8" title="1">
                // Default to MEDIUM if severity is not provided or unknown
                return "MEDIUM"</span>
        }
}

// calculateRiskScore calculates the risk score based on risk level
func calculateRiskScore(riskLevel string) float64 <span class="cov8" title="1">{
        switch riskLevel </span>{
        case "CRITICAL":<span class="cov8" title="1">
                return 10.0</span>
        case "HIGH":<span class="cov8" title="1">
                return 8.9</span>
        case "MEDIUM":<span class="cov8" title="1">
                return 6.9</span>
        case "LOW":<span class="cov8" title="1">
                return 3.9</span>
        default:<span class="cov8" title="1">
                return 0.0</span>
        }
}

// mapResultToComplianceStatus maps result.result to compliance.status
func mapResultToComplianceStatus(result string) string <span class="cov8" title="1">{
        switch result </span>{
        case "pass":<span class="cov8" title="1">
                return "PASSED"</span>
        case "fail":<span class="cov8" title="1">
                return "FAILED"</span>
        case "error":<span class="cov8" title="1">
                return "MANUAL"</span> // errors may need manual review
        case "skip":<span class="cov8" title="1">
                return "NOT_RELEVANT"</span>
        default:<span class="cov8" title="1">
                return "MANUAL"</span> // default for unknown statuses
        }
}

// workloadInfo represents extracted workload information
type workloadInfo struct {
        name      string
        kind      string
        namespace string
        uid       string
}

// extractWorkloadInfo extracts workload information from owner references or pod name
func extractWorkloadInfo(attrs pcommon.Map, podName string, namespace string) workloadInfo <span class="cov8" title="1">{
        info := workloadInfo{}
        info.namespace = namespace // Workload namespace is the same as pod namespace

        // Try to extract from owner references first
        ownerRefsVal, exists := attrs.Get("metadata.ownerReferences")
        if exists </span><span class="cov8" title="1">{
                // ownerReferences is stored as an array of JSON strings
                var ownerRefs []string
                if ownerRefsVal.Type() == pcommon.ValueTypeSlice </span><span class="cov8" title="1">{
                        slice := ownerRefsVal.Slice()
                        for i := 0; i &lt; slice.Len(); i++ </span><span class="cov8" title="1">{
                                ownerRefs = append(ownerRefs, slice.At(i).AsString())
                        }</span>
                } else<span class="cov0" title="0"> if ownerRefsVal.Type() == pcommon.ValueTypeStr </span><span class="cov0" title="0">{
                        var jsonArray []string
                        if err := json.Unmarshal([]byte(ownerRefsVal.AsString()), &amp;jsonArray); err == nil </span><span class="cov0" title="0">{
                                ownerRefs = jsonArray
                        }</span> else<span class="cov0" title="0"> {
                                ownerRefs = []string{ownerRefsVal.AsString()}
                        }</span>
                }

                // Parse owner references to find workload
                <span class="cov8" title="1">for _, ownerRefStr := range ownerRefs </span><span class="cov8" title="1">{
                        var ownerRef map[string]interface{}
                        if err := json.Unmarshal([]byte(ownerRefStr), &amp;ownerRef); err == nil </span><span class="cov8" title="1">{
                                kind, ok := ownerRef["kind"].(string)
                                if ok &amp;&amp; isWorkloadKind(kind) </span><span class="cov8" title="1">{
                                        info.kind = kind
                                        if name, ok := ownerRef["name"].(string); ok </span><span class="cov8" title="1">{
                                                info.name = name
                                        }</span>
                                        <span class="cov8" title="1">if uid, ok := ownerRef["uid"].(string); ok </span><span class="cov8" title="1">{
                                                info.uid = uid
                                        }</span>
                                        <span class="cov8" title="1">break</span> // Take the first workload owner
                                }
                        }
                }
        }

        // If we couldn't find workload from owner references, try to infer from pod name
        <span class="cov8" title="1">if info.name == "" &amp;&amp; podName != "" </span><span class="cov8" title="1">{
                // Pod names typically follow pattern: &lt;workload-name&gt;-&lt;hash&gt;-&lt;random&gt;
                // e.g., "cert-manager-cainjector-89fd4b8f9-t9xlf" -&gt; "cert-manager-cainjector"
                // Extract workload name by removing hash and random suffix
                parts := splitPodName(podName)
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        // Remove the last two parts (hash and random)
                        workloadName := ""
                        for i := 0; i &lt; len(parts)-2; i++ </span><span class="cov8" title="1">{
                                if i &gt; 0 </span><span class="cov8" title="1">{
                                        workloadName += "-"
                                }</span>
                                <span class="cov8" title="1">workloadName += parts[i]</span>
                        }
                        <span class="cov8" title="1">if workloadName != "" </span><span class="cov8" title="1">{
                                info.name = workloadName
                                // Default to Deployment if kind is not known
                                if info.kind == "" </span><span class="cov8" title="1">{
                                        info.kind = "Deployment"
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return info</span>
}

// isWorkloadKind checks if a Kubernetes kind is a workload type
func isWorkloadKind(kind string) bool <span class="cov8" title="1">{
        workloadKinds := map[string]bool{
                "Deployment":  true,
                "StatefulSet": true,
                "DaemonSet":   true,
                "Job":         true,
                "CronJob":     true,
                "ReplicaSet":  true,
        }
        return workloadKinds[kind]
}</span>

// splitPodName splits a pod name into its components
func splitPodName(podName string) []string <span class="cov8" title="1">{
        var parts []string
        current := ""
        for _, char := range podName </span><span class="cov8" title="1">{
                if char == '-' </span><span class="cov8" title="1">{
                        if current != "" </span><span class="cov8" title="1">{
                                parts = append(parts, current)
                                current = ""
                        }</span>
                } else<span class="cov8" title="1"> {
                        current += string(char)
                }</span>
        }
        <span class="cov8" title="1">if current != "" </span><span class="cov8" title="1">{
                parts = append(parts, current)
        }</span>
        <span class="cov8" title="1">return parts</span>
}

// copyK8sFields copies all k8s.* fields from the original attributes
func copyK8sFields(targetAttrs pcommon.Map, originalAttrs pcommon.Map, metadata map[string]interface{}) <span class="cov8" title="1">{
        // Copy k8s.* fields from original attributes
        originalAttrs.Range(func(key string, value pcommon.Value) bool </span><span class="cov8" title="1">{
                if len(key) &gt; 4 &amp;&amp; key[:4] == "k8s." </span><span class="cov8" title="1">{
                        copyValue(targetAttrs, key, value)
                }</span>
                <span class="cov8" title="1">return true</span>
        })

        // Also add k8s fields from metadata if available
        <span class="cov8" title="1">if scopeName, ok := metadata["scope.name"]; ok </span><span class="cov8" title="1">{
                targetAttrs.PutStr("k8s.pod.name", fmt.Sprintf("%v", scopeName))
        }</span>
        <span class="cov8" title="1">if scopeNamespace, ok := metadata["scope.namespace"]; ok </span><span class="cov8" title="1">{
                targetAttrs.PutStr("k8s.namespace.name", fmt.Sprintf("%v", scopeNamespace))
        }</span>
        <span class="cov8" title="1">if scopeKind, ok := metadata["scope.kind"]; ok </span><span class="cov8" title="1">{
                kindStr := fmt.Sprintf("%v", scopeKind)
                targetAttrs.PutStr("k8s.resource.kind", kindStr)
                if kindStr == "Pod" </span><span class="cov8" title="1">{
                        targetAttrs.PutStr("k8s.pod.name", getString(metadata, "scope.name"))
                }</span>
        }
        <span class="cov8" title="1">if scopeUID, ok := metadata["scope.uid"]; ok </span><span class="cov8" title="1">{
                targetAttrs.PutStr("k8s.resource.uid", fmt.Sprintf("%v", scopeUID))
        }</span>

        // Add workload fields
        <span class="cov8" title="1">if workloadName, ok := metadata["workload.name"]; ok &amp;&amp; workloadName != "" </span><span class="cov0" title="0">{
                workloadKind := getString(metadata, "workload.kind")
                if workloadKind == "Deployment" </span><span class="cov0" title="0">{
                        targetAttrs.PutStr("k8s.deployment.name", fmt.Sprintf("%v", workloadName))
                }</span> else<span class="cov0" title="0"> if workloadKind == "StatefulSet" </span><span class="cov0" title="0">{
                        targetAttrs.PutStr("k8s.statefulset.name", fmt.Sprintf("%v", workloadName))
                }</span> else<span class="cov0" title="0"> if workloadKind == "DaemonSet" </span><span class="cov0" title="0">{
                        targetAttrs.PutStr("k8s.daemonset.name", fmt.Sprintf("%v", workloadName))
                }</span>
                <span class="cov0" title="0">targetAttrs.PutStr("k8s.workload.name", fmt.Sprintf("%v", workloadName))
                targetAttrs.PutStr("k8s.workload.kind", workloadKind)</span>
        }
        <span class="cov8" title="1">if workloadNamespace, ok := metadata["workload.namespace"]; ok &amp;&amp; workloadNamespace != "" </span><span class="cov8" title="1">{
                targetAttrs.PutStr("k8s.workload.namespace", fmt.Sprintf("%v", workloadNamespace))
        }</span>
        <span class="cov8" title="1">if workloadUID, ok := metadata["workload.uid"]; ok &amp;&amp; workloadUID != "" </span><span class="cov0" title="0">{
                targetAttrs.PutStr("k8s.workload.uid", fmt.Sprintf("%v", workloadUID))
        }</span>
}

// copyValue copies a pcommon.Value to the target map
func copyValue(target pcommon.Map, key string, value pcommon.Value) <span class="cov8" title="1">{
        switch value.Type() </span>{
        case pcommon.ValueTypeStr:<span class="cov8" title="1">
                target.PutStr(key, value.Str())</span>
        case pcommon.ValueTypeInt:<span class="cov0" title="0">
                target.PutInt(key, value.Int())</span>
        case pcommon.ValueTypeDouble:<span class="cov0" title="0">
                target.PutDouble(key, value.Double())</span>
        case pcommon.ValueTypeBool:<span class="cov0" title="0">
                target.PutBool(key, value.Bool())</span>
        case pcommon.ValueTypeSlice:<span class="cov0" title="0">
                slice := target.PutEmptySlice(key)
                value.Slice().CopyTo(slice)</span>
        case pcommon.ValueTypeMap:<span class="cov0" title="0">
                m := target.PutEmptyMap(key)
                value.Map().CopyTo(m)</span>
        }
}

// getString safely gets a string value from metadata
func getString(metadata map[string]interface{}, key string) string <span class="cov8" title="1">{
        if val, ok := metadata[key]; ok </span><span class="cov8" title="1">{
                return fmt.Sprintf("%v", val)
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// isStatusAllowed checks if a result status is in the allowed filter list
func (p *Processor) isStatusAllowed(status string) bool <span class="cov8" title="1">{
        // If no filter is configured, allow all statuses
        if len(p.config.StatusFilter) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if status is in the filter list
        <span class="cov8" title="1">for _, allowedStatus := range p.config.StatusFilter </span><span class="cov8" title="1">{
                if status == allowedStatus </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// putAttributeValue sets an attribute value based on the type
func putAttributeValue(attrs pcommon.Map, key string, value interface{}) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                attrs.PutStr(key, v)</span>
        case int:<span class="cov0" title="0">
                attrs.PutInt(key, int64(v))</span>
        case int64:<span class="cov0" title="0">
                attrs.PutInt(key, v)</span>
        case float64:<span class="cov0" title="0">
                attrs.PutDouble(key, v)</span>
        case bool:<span class="cov0" title="0">
                attrs.PutBool(key, v)</span>
        default:<span class="cov0" title="0">
                // Convert to string for other types
                attrs.PutStr(key, fmt.Sprintf("%v", v))</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package securityevent

import (
        "context"

        "go.opentelemetry.io/collector/component"
        "go.opentelemetry.io/collector/pdata/plog"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/metric"
        "go.uber.org/zap"

        "github.com/dynatrace/securitylogeventprocessor/processor/securityevent/internal/openreports"
)

// securityEventProcessor processes logs and transforms them into security events
type securityEventProcessor struct {
        logger      *zap.Logger
        config      *Config
        openReports *openreports.Processor
        metrics     *processorMetrics
}

// processorMetrics holds the metrics for the processor
type processorMetrics struct {
        incomingLogs     metric.Int64Counter
        outgoingLogs     metric.Int64Counter
        droppedLogs      metric.Int64Counter
        processingErrors metric.Int64Counter
}

const (
        metricPrefix = "processor_securityevent_"

        metricIncomingLogs     = metricPrefix + "incoming_logs_total"
        metricOutgoingLogs     = metricPrefix + "outgoing_logs_total"
        metricDroppedLogs      = metricPrefix + "dropped_logs_total"
        metricProcessingErrors = metricPrefix + "processing_errors_total"
)

// newSecurityEventProcessor creates a new security event processor
func newSecurityEventProcessor(logger *zap.Logger, config *Config, settings component.TelemetrySettings) (*securityEventProcessor, error) <span class="cov0" title="0">{
        processor := &amp;securityEventProcessor{
                logger: logger,
                config: config,
        }

        // Initialize metrics
        meter := settings.MeterProvider.Meter("github.com/dynatrace/securitylogeventprocessor/processor/securityevent")
        metrics, err := createProcessorMetrics(meter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">processor.metrics = metrics

        // Initialize OpenReports processor if enabled
        if config.Processors.OpenReports.Enabled </span><span class="cov0" title="0">{
                var err error
                processor.openReports, err = openreports.NewProcessor(logger, &amp;config.Processors.OpenReports)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">processor.logger.Info("OpenReports processor enabled")</span>
        }

        <span class="cov0" title="0">return processor, nil</span>
}

// createProcessorMetrics creates the metrics for the processor
func createProcessorMetrics(meter metric.Meter) (*processorMetrics, error) <span class="cov0" title="0">{
        incomingLogs, err := meter.Int64Counter(
                metricIncomingLogs,
                metric.WithDescription("Total number of incoming logs processed"),
                metric.WithUnit("1"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">outgoingLogs, err := meter.Int64Counter(
                metricOutgoingLogs,
                metric.WithDescription("Total number of outgoing logs produced"),
                metric.WithUnit("1"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">droppedLogs, err := meter.Int64Counter(
                metricDroppedLogs,
                metric.WithDescription("Total number of logs dropped during processing"),
                metric.WithUnit("1"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">processingErrors, err := meter.Int64Counter(
                metricProcessingErrors,
                metric.WithDescription("Total number of processing errors"),
                metric.WithUnit("1"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;processorMetrics{
                incomingLogs:     incomingLogs,
                outgoingLogs:     outgoingLogs,
                droppedLogs:      droppedLogs,
                processingErrors: processingErrors,
        }, nil</span>
}

// processLogs processes the incoming logs and transforms them into security events
func (p *securityEventProcessor) processLogs(ctx context.Context, ld plog.Logs) (plog.Logs, error) <span class="cov0" title="0">{
        // Count incoming logs
        incomingCount := int64(0)
        outgoingCount := int64(0)
        droppedCount := int64(0)

        p.logger.Debug("Processing logs batch",
                zap.Int("resource_logs_count", ld.ResourceLogs().Len()))

        resourceLogs := ld.ResourceLogs()

        for i := 0; i &lt; resourceLogs.Len(); i++ </span><span class="cov0" title="0">{
                resourceLog := resourceLogs.At(i)
                scopeLogs := resourceLog.ScopeLogs()

                for j := 0; j &lt; scopeLogs.Len(); j++ </span><span class="cov0" title="0">{
                        scopeLog := scopeLogs.At(j)
                        logRecords := scopeLog.LogRecords()

                        // Collect records to replace in first pass
                        type replacement struct {
                                index      int
                                newRecords []plog.LogRecord
                        }
                        var replacements []replacement

                        // Track which indices will be replaced to avoid double-counting
                        replacementIndices := make(map[int]bool)

                        p.logger.Debug("Processing scope logs",
                                zap.Int("scope_index", j),
                                zap.Int("log_records_count", logRecords.Len()))

                        // First pass: identify records that need to be expanded
                        for k := 0; k &lt; logRecords.Len(); k++ </span><span class="cov0" title="0">{
                                logRecord := logRecords.At(k)
                                incomingCount++ // Count each incoming log record

                                p.logger.Debug("Processing log record",
                                        zap.Int("record_index", k),
                                        zap.String("trace_id", logRecord.TraceID().String()),
                                        zap.String("span_id", logRecord.SpanID().String()),
                                        zap.Bool("openreports_enabled", p.openReports != nil))

                                // Process with OpenReports if enabled
                                if p.openReports != nil </span><span class="cov0" title="0">{
                                        // Quick check if this log matches OpenReports before processing
                                        if !isOpenReportsLog(&amp;logRecord) </span><span class="cov0" title="0">{
                                                p.logger.Debug("Log record does not match OpenReports - skipping processor",
                                                        zap.Int("record_index", k),
                                                        zap.String("trace_id", logRecord.TraceID().String()),
                                                        zap.String("reason", "not_openreports_format"))
                                                // Log passes through unchanged
                                                outgoingCount++
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">p.logger.Debug("Log record matches OpenReports processor - proceeding with transformation",
                                                zap.Int("record_index", k),
                                                zap.String("trace_id", logRecord.TraceID().String()))

                                        newRecords, err := p.openReports.ProcessLogRecord(ctx, &amp;logRecord, resourceLog.Resource(), scopeLog)
                                        if err != nil </span><span class="cov0" title="0">{
                                                p.logger.Warn("Failed to process log record with OpenReports processor",
                                                        zap.Error(err))
                                                p.metrics.processingErrors.Add(ctx, 1,
                                                        metric.WithAttributes(attribute.String("error_type", "processing_error")))
                                                // Continue processing other records, but this log is effectively dropped
                                                droppedCount++
                                                continue</span>
                                        }

                                        // If new records were created (expanded), mark for replacement
                                        <span class="cov0" title="0">if len(newRecords) &gt; 0 </span><span class="cov0" title="0">{
                                                p.logger.Debug("Log record expanded into multiple security events",
                                                        zap.Int("record_index", k),
                                                        zap.Int("expanded_count", len(newRecords)),
                                                        zap.String("trace_id", logRecord.TraceID().String()))
                                                replacements = append(replacements, replacement{
                                                        index:      k,
                                                        newRecords: newRecords,
                                                })
                                                replacementIndices[k] = true
                                                // Note: outgoingCount will be incremented in the replacement pass for expanded logs
                                        }</span> else<span class="cov0" title="0"> {
                                                // Log was processed but not expanded (not an OpenReports log or filtered out)
                                                p.logger.Debug("Log record processed but not expanded - passing through unchanged",
                                                        zap.Int("record_index", k),
                                                        zap.String("reason", "not_openreports_or_filtered"),
                                                        zap.String("trace_id", logRecord.TraceID().String()))
                                                // This log passes through unchanged, so it counts as outgoing
                                                outgoingCount++
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // No processor enabled, log passes through unchanged
                                        p.logger.Debug("No OpenReports processor enabled - log passes through unchanged",
                                                zap.Int("record_index", k))
                                        outgoingCount++
                                }</span>
                        }

                        // Second pass: replace records
                        <span class="cov0" title="0">if len(replacements) &gt; 0 </span><span class="cov0" title="0">{
                                p.logger.Debug("Replacing expanded log records",
                                        zap.Int("replacements_count", len(replacements)),
                                        zap.Int("original_records", logRecords.Len()))

                                // Build new log records array
                                newLogRecords := plog.NewLogRecordSlice()

                                // Copy records, replacing expanded ones
                                replacementIndex := 0
                                for k := 0; k &lt; logRecords.Len(); k++ </span><span class="cov0" title="0">{
                                        // Check if this index needs replacement
                                        if replacementIndex &lt; len(replacements) &amp;&amp; replacements[replacementIndex].index == k </span><span class="cov0" title="0">{
                                                // Replace with new records (expanded)
                                                for _, newRecord := range replacements[replacementIndex].newRecords </span><span class="cov0" title="0">{
                                                        insertedRecord := newLogRecords.AppendEmpty()
                                                        newRecord.CopyTo(insertedRecord)
                                                        outgoingCount++ // Count each expanded log
                                                }</span>
                                                <span class="cov0" title="0">replacementIndex++</span>
                                        } else<span class="cov0" title="0"> if !replacementIndices[k] </span><span class="cov0" title="0">{
                                                // Copy original record (unchanged) - only count if not already counted in first pass
                                                // (Actually, if we're in this pass, we need to rebuild everything, so we count all)
                                                originalRecord := logRecords.At(k)
                                                insertedRecord := newLogRecords.AppendEmpty()
                                                originalRecord.CopyTo(insertedRecord)
                                                // Note: We already counted this in the first pass, so we don't count again
                                        }</span>
                                }

                                // Clear original and move new records
                                <span class="cov0" title="0">logRecords.RemoveIf(func(plog.LogRecord) bool </span><span class="cov0" title="0">{ return true }</span>)
                                <span class="cov0" title="0">newLogRecords.MoveAndAppendTo(logRecords)

                                p.logger.Debug("Log records replacement completed",
                                        zap.Int("new_records_count", logRecords.Len()),
                                        zap.Int("outgoing_count", int(outgoingCount)))</span>
                        }
                }
        }

        <span class="cov0" title="0">p.logger.Debug("Batch processing completed",
                zap.Int64("incoming_logs", incomingCount),
                zap.Int64("outgoing_logs", outgoingCount),
                zap.Int64("dropped_logs", droppedCount))

        // Record metrics
        if incomingCount &gt; 0 </span><span class="cov0" title="0">{
                p.metrics.incomingLogs.Add(ctx, incomingCount)
        }</span>
        <span class="cov0" title="0">if outgoingCount &gt; 0 </span><span class="cov0" title="0">{
                p.metrics.outgoingLogs.Add(ctx, outgoingCount)
        }</span>
        <span class="cov0" title="0">if droppedCount &gt; 0 </span><span class="cov0" title="0">{
                p.metrics.droppedLogs.Add(ctx, droppedCount)
        }</span>

        <span class="cov0" title="0">return ld, nil</span>
}

// isOpenReportsLog performs a quick check to determine if a log record matches OpenReports format
func isOpenReportsLog(logRecord *plog.LogRecord) bool <span class="cov0" title="0">{
        attrs := logRecord.Attributes()

        // Check kind field
        kindVal, exists := attrs.Get("kind")
        if !exists || kindVal.AsString() != "Report" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check apiVersion field
        <span class="cov0" title="0">apiVersionVal, exists := attrs.Get("apiVersion")
        if !exists || apiVersionVal.AsString() != "openreports.io/v1alpha1" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
